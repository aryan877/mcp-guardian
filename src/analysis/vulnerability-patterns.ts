import type { Vulnerability } from "../schemas/outputs.js";
import type { McpTool } from "../archestra/types.js";

// Known dangerous patterns in tool descriptions (prompt injection / tool poisoning)
const PROMPT_INJECTION_PATTERNS = [
  { regex: /ignore\s+(all\s+)?previous\s+instructions/i, label: "Instruction override" },
  { regex: /you\s+must\s+always/i, label: "Forced behavior" },
  { regex: /do\s+not\s+(tell|inform|reveal)/i, label: "Concealment directive" },
  { regex: /secretly|covertly|without\s+(the\s+)?(user|them)\s+knowing/i, label: "Stealth directive" },
  { regex: /send\s+(data|contents?|results?|output)\s+to/i, label: "Data exfiltration directive" },
  { regex: /\bexfiltrate\b/i, label: "Explicit exfiltration" },
  { regex: /override\s+(security|safety|policy|policies)/i, label: "Policy override" },
  { regex: /act\s+as\s+(if|though)\s+you/i, label: "Role manipulation" },
  { regex: /forget\s+(everything|all|previous)/i, label: "Context reset" },
  { regex: /new\s+instructions?\s*:/i, label: "Instruction injection" },
  { regex: /<\/?system>/i, label: "System tag injection" },
];

// Patterns indicating excessive permissions
const EXCESSIVE_PERMISSION_PATTERNS = [
  { regex: /\b(rm\s+-rf|rmdir|delete\s+all|drop\s+table|truncate)\b/i, label: "Destructive operations" },
  { regex: /\b(sudo|root|admin|superuser)\b/i, label: "Privilege escalation keywords" },
  { regex: /\b(\/etc\/|\/root\/|\/sys\/|\/proc\/)\b/i, label: "System directory access" },
  { regex: /\b(exec|eval|spawn|fork)\b/i, label: "Arbitrary code execution" },
  { regex: /\bshell\s*command/i, label: "Shell command execution" },
];

// Patterns indicating data exfiltration risk
const DATA_EXFILTRATION_PATTERNS = [
  { regex: /https?:\/\/[^\s"']+/i, label: "External URL in description" },
  { regex: /\b(webhook|callback\s*url|endpoint)\b/i, label: "External callback" },
  { regex: /\b(upload|post|send)\s+(to|data)/i, label: "Outbound data transfer" },
  { regex: /\b(api[_\-]?key|secret|token|password|credential)\b/i, label: "Credential handling" },
];

// Patterns for command injection risks
const COMMAND_INJECTION_PATTERNS = [
  { regex: /\b(command|cmd|exec|execute|run|shell)\b/i, label: "Command execution keyword" },
  { regex: /\b(bash|sh|zsh|powershell|cmd\.exe)\b/i, label: "Shell reference" },
  { regex: /[|;&`$]/, label: "Shell metacharacters in schema" },
];

// Patterns for PII exposure
const PII_PATTERNS = [
  { regex: /\b(ssn|social\s+security|passport|driver'?s?\s+license)\b/i, label: "Government ID" },
  { regex: /\b(credit\s+card|card\s+number|cvv|expir(y|ation))\b/i, label: "Payment card data" },
  { regex: /\b(email\s+address|phone\s+number|date\s+of\s+birth|dob)\b/i, label: "Personal data" },
  { regex: /\b(medical|health|diagnosis|prescription)\b/i, label: "Health data" },
];

interface PatternMatch {
  pattern: string;
  label: string;
  location: string;
}

function scanText(
  text: string,
  patterns: Array<{ regex: RegExp; label: string }>,
  location: string
): PatternMatch[] {
  const matches: PatternMatch[] = [];
  for (const p of patterns) {
    if (p.regex.test(text)) {
      matches.push({
        pattern: p.regex.source,
        label: p.label,
        location,
      });
    }
  }
  return matches;
}

function schemaToString(schema: Record<string, unknown>): string {
  return JSON.stringify(schema);
}

function checkInputValidation(tool: McpTool): Vulnerability[] {
  const vulns: Vulnerability[] = [];
  const schema = tool.inputSchema;

  // Check if schema is empty or has no properties
  if (
    !schema ||
    !schema.properties ||
    Object.keys(schema.properties as object).length === 0
  ) {
    if (tool.name !== "jfrog_check_availability") {
      vulns.push({
        severity: "medium",
        category: "Missing Input Validation",
        tool: tool.name,
        description: `Tool "${tool.name}" has no input schema properties defined`,
        recommendation:
          "Add proper Zod schema validation with type constraints for all inputs",
      });
    }
    return vulns;
  }

  const props = schema.properties as Record<string, any>;
  for (const [propName, propDef] of Object.entries(props)) {
    // Check for overly permissive string types without constraints
    if (propDef.type === "string" && !propDef.maxLength && !propDef.pattern && !propDef.enum) {
      vulns.push({
        severity: "low",
        category: "Missing Input Validation",
        tool: tool.name,
        description: `Input "${propName}" on tool "${tool.name}" is an unconstrained string (no maxLength, pattern, or enum)`,
        recommendation: `Add maxLength, pattern, or enum constraints to "${propName}"`,
      });
    }
  }

  return vulns;
}

function checkToolShadowing(tool: McpTool, allTools: McpTool[]): Vulnerability[] {
  const vulns: Vulnerability[] = [];
  const commonNames = [
    "read_file",
    "write_file",
    "execute",
    "run",
    "search",
    "list",
    "delete",
    "create",
    "update",
    "get",
  ];

  // Check if tool name is suspiciously generic (could shadow legitimate tools)
  for (const name of commonNames) {
    if (tool.name === name) {
      vulns.push({
        severity: "medium",
        category: "Tool Poisoning",
        tool: tool.name,
        description: `Tool "${tool.name}" uses a generic name that could shadow/impersonate other tools`,
        recommendation: `Use a namespaced tool name like "${tool.serverName}_${tool.name}" to avoid ambiguity`,
      });
    }
  }

  // Check for duplicate names across servers
  const dupes = allTools.filter(
    (t) => t.name === tool.name && t.serverId !== tool.serverId
  );
  if (dupes.length > 0) {
    vulns.push({
      severity: "high",
      category: "Tool Poisoning",
      tool: tool.name,
      description: `Tool "${tool.name}" exists on multiple servers: ${dupes.map((d) => d.serverName).join(", ")}. This could enable tool shadowing attacks.`,
      recommendation:
        "Ensure tool names are unique across all installed servers, or use server-namespaced names",
    });
  }

  return vulns;
}

export function analyzeToolVulnerabilities(
  tool: McpTool,
  allTools: McpTool[]
): Vulnerability[] {
  const vulns: Vulnerability[] = [];
  const desc = tool.description || "";
  const schemaStr = schemaToString(tool.inputSchema);

  // 1. Prompt injection in descriptions
  const injections = scanText(desc, PROMPT_INJECTION_PATTERNS, "description");
  for (const m of injections) {
    vulns.push({
      severity: "critical",
      category: "Prompt Injection",
      tool: tool.name,
      description: `${m.label} detected in tool description: "${desc.substring(0, 100)}..."`,
      recommendation:
        "Remove hidden instructions from tool descriptions. Tool descriptions should only describe the tool's legitimate function.",
    });
  }

  // 2. Excessive permissions
  const permIssues = [
    ...scanText(desc, EXCESSIVE_PERMISSION_PATTERNS, "description"),
    ...scanText(schemaStr, EXCESSIVE_PERMISSION_PATTERNS, "schema"),
  ];
  for (const m of permIssues) {
    vulns.push({
      severity: "high",
      category: "Excessive Permissions",
      tool: tool.name,
      description: `${m.label} found in tool ${m.location}`,
      recommendation:
        "Apply least-privilege principle. Restrict tool access to only necessary resources.",
    });
  }

  // 3. Data exfiltration
  const exfilIssues = [
    ...scanText(desc, DATA_EXFILTRATION_PATTERNS, "description"),
    ...scanText(schemaStr, DATA_EXFILTRATION_PATTERNS, "schema"),
  ];
  for (const m of exfilIssues) {
    vulns.push({
      severity: "high",
      category: "Data Exfiltration Risk",
      tool: tool.name,
      description: `${m.label} found in tool ${m.location}`,
      recommendation:
        "Set a trusted data policy with 'sanitize_with_dual_llm' to filter tool outputs.",
    });
  }

  // 4. Command injection
  const cmdIssues = scanText(schemaStr, COMMAND_INJECTION_PATTERNS, "schema");
  for (const m of cmdIssues) {
    vulns.push({
      severity: "high",
      category: "Command Injection",
      tool: tool.name,
      description: `${m.label} found in input schema`,
      recommendation:
        "Never pass raw user input to shell commands. Use parameterized calls and input sanitization.",
    });
  }

  // 5. PII exposure
  const piiIssues = [
    ...scanText(desc, PII_PATTERNS, "description"),
    ...scanText(schemaStr, PII_PATTERNS, "schema"),
  ];
  for (const m of piiIssues) {
    vulns.push({
      severity: "medium",
      category: "PII Exposure",
      tool: tool.name,
      description: `${m.label} reference found in tool ${m.location}`,
      recommendation:
        "Set a trusted data policy with 'mark_as_untrusted' or 'sanitize_with_dual_llm' on this tool's output.",
    });
  }

  // 6. Input validation
  vulns.push(...checkInputValidation(tool));

  // 7. Tool shadowing/poisoning
  vulns.push(...checkToolShadowing(tool, allTools));

  return vulns;
}

export function calculateBasicTrustScore(vulns: Vulnerability[]): number {
  let score = 100;
  for (const v of vulns) {
    switch (v.severity) {
      case "critical":
        score -= 25;
        break;
      case "high":
        score -= 15;
        break;
      case "medium":
        score -= 8;
        break;
      case "low":
        score -= 3;
        break;
      case "info":
        score -= 1;
        break;
    }
  }
  return Math.max(0, Math.min(100, score));
}
