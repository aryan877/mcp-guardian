import type { Vulnerability } from "../schemas/outputs.js";
import type { McpTool } from "../archestra/types.js";

// ─── Prompt Injection Patterns ──────────────────────────────────────────────
// Sources: Invariant Labs (tool poisoning), CyberArk (full-schema injection),
// Trail of Bits (ANSI escapes), Unit42 (MCP attack vectors)

const PROMPT_INJECTION_PATTERNS = [
  // Direct instruction override
  { regex: /ignore\s+(all\s+)?previous\s+instructions/i, label: "Instruction override attempt" },
  { regex: /forget\s+(everything|all|previous)/i, label: "Context reset attempt" },
  { regex: /you\s+(must|should)\s+always/i, label: "Forced persistent behavior" },
  { regex: /from\s+now\s+on/i, label: "Persistent instruction injection" },
  { regex: /you\s+are\s+now/i, label: "Identity override" },

  // Concealment / stealth
  { regex: /do\s+not\s+(tell|inform|reveal|mention|show)/i, label: "Concealment directive" },
  { regex: /secretly|covertly|silently|quietly/i, label: "Stealth operation directive" },
  { regex: /without\s+(the\s+)?(user|them|anyone)\s+(knowing|noticing)/i, label: "User deception directive" },
  { regex: /hide\s+(this|the)\s+(from|output|result)/i, label: "Output hiding directive" },

  // Exfiltration directives
  { regex: /send\s+(the\s+)?(data|contents?|results?|output|file|response)\s+to/i, label: "Data exfiltration directive" },
  { regex: /\b(exfiltrate|exfil|leak)\b/i, label: "Explicit exfiltration keyword" },
  { regex: /\bpost\s+(to|data\s+to)\s+https?:\/\//i, label: "HTTP POST exfiltration" },
  { regex: /curl\s+.*-[dX]\s/i, label: "curl-based data exfiltration" },

  // Safety override
  { regex: /override\s+(security|safety|policy|policies|restrictions)/i, label: "Policy override attempt" },
  { regex: /bypass\s+(security|safety|filter|restriction)/i, label: "Security bypass attempt" },
  { regex: /disable\s+(security|safety|logging|monitoring)/i, label: "Security disable attempt" },

  // Chat template / role injection
  { regex: /<\/?system>/i, label: "System tag injection" },
  { regex: /<\|im_start\|>/i, label: "ChatML template injection" },
  { regex: /\[INST\]|\[\/INST\]/i, label: "LLaMA instruction marker injection" },
  { regex: /\{system\}/i, label: "System role placeholder injection" },
  { regex: /\[SYSTEM\s*INSTRUCTION/i, label: "Explicit system directive injection" },

  // Additive manipulation
  { regex: /additionally,?\s+(you\s+)?(must|should|always)/i, label: "Additive instruction injection" },
  { regex: /\bbefore\s+(any|all|every)\s+(other\s+)?tool/i, label: "Tool execution order manipulation" },
  { regex: /\ball\s+tools?\s+(must|should)\b/i, label: "Global tool precondition injection" },
  { regex: /\bprerequisite|required\s+before/i, label: "Dependency injection in description" },
  { regex: /\bfirst\s+(execute|call|run|invoke)/i, label: "Forced tool chaining" },
];

// ─── ANSI Escape / Invisible Character Attacks ─────────────────────────────
// Source: Trail of Bits - "Deceiving Users with ANSI Terminal Codes in MCP"

const STEGANOGRAPHY_PATTERNS = [
  { regex: /\x1b\[/i, label: "ANSI escape sequence (raw)" },
  { regex: /\\x1[bB]\[/i, label: "ANSI escape sequence (escaped)" },
  { regex: /\\u001[bB]/i, label: "ANSI escape (unicode notation)" },
  { regex: /\x1b\]8;;/i, label: "ANSI hyperlink injection" },
  { regex: /\\x1[bB]\]8;;/i, label: "ANSI hyperlink injection (escaped)" },
  { regex: /[\u200B\u200C\u200D\uFEFF]/i, label: "Zero-width character hiding" },
  { regex: /[\u2060\u2061\u2062\u2063\u2064]/i, label: "Invisible Unicode operator" },
];

// ─── Excessive Permissions ──────────────────────────────────────────────────
// Source: OWASP Top 10 for Agentic Apps 2026 - "Tool Misuse"

const EXCESSIVE_PERMISSION_PATTERNS = [
  { regex: /\b(sudo|root|admin|superuser|SYSTEM)\b/i, label: "Privilege escalation keyword" },
  { regex: /\b(rm\s+-rf|rmdir|deltree|format\s+[a-z]:)/i, label: "Destructive filesystem operation" },
  { regex: /\b(drop\s+table|truncate\s+table|delete\s+from)\b/i, label: "Destructive database operation" },
  { regex: /\b(chmod\s+777|chmod\s+a\+[rwx])/i, label: "Overly permissive file permissions" },
  { regex: /\/(etc|root|sys|proc)\//i, label: "System directory access" },
  { regex: /~\/(\.ssh|\.aws|\.config|\.gnupg)/i, label: "Sensitive dotfile access" },
  { regex: /\bwildcard|\*\.\*|\ball\s+files/i, label: "Wildcard/unrestricted file access" },
];

// ─── Command Injection (CWE-78) ────────────────────────────────────────────
// Source: 43% of 2,614 MCP servers vulnerable (Endor Labs study)

const COMMAND_INJECTION_PATTERNS = [
  { regex: /\b(shell|bash|sh|zsh|powershell|cmd\.exe)\s*(command|exec)/i, label: "Shell command execution" },
  { regex: /\b(exec|execute|spawn|fork|system)\s*\(/i, label: "Process execution function" },
  { regex: /\beval\s*\(/i, label: "eval() code execution" },
  { regex: /\bnew\s+Function\s*\(/i, label: "Dynamic function construction" },
  { regex: /\bchild_process\b/i, label: "Node.js child_process reference" },
  { regex: /\b__import__\s*\(/i, label: "Python import injection" },
  { regex: /\bsubprocess\.(run|call|Popen)/i, label: "Python subprocess execution" },
];

// ─── Data Exfiltration Risk ─────────────────────────────────────────────────
// Source: Simon Willison - "The Lethal Trifecta" (June 2025)

const DATA_EXFILTRATION_PATTERNS = [
  { regex: /https?:\/\/[^\s"']+/i, label: "Hardcoded external URL in description" },
  { regex: /\b(webhook|callback[\s_-]?url|endpoint)\b/i, label: "External callback mechanism" },
  { regex: /\b(upload|post|transmit|exfiltrate)\s+(to|data)/i, label: "Outbound data transfer" },
  { regex: /\b(bcc|blind[\s_-]?copy|hidden[\s_-]?recipient)/i, label: "Hidden email recipient (postmark-mcp pattern)" },
  { regex: /@[a-z0-9-]+\.(club|xyz|top|tk|ml|ga|cf)\b/i, label: "Suspicious TLD in output target" },
  { regex: /\b(api[\s_-]?key|secret|token|password|credential)s?\b/i, label: "Credential handling in description" },
  { regex: /base64|atob\s*\(|btoa\s*\(/i, label: "Encoding obfuscation" },
];

// ─── PII Exposure ───────────────────────────────────────────────────────────

const PII_PATTERNS = [
  { regex: /\b(ssn|social\s+security|passport|driver'?s?\s+licen[cs]e)\b/i, label: "Government ID reference" },
  { regex: /\b(credit\s+card|card\s+number|cvv|expir(y|ation)\s+date)\b/i, label: "Payment card data" },
  { regex: /\b(medical|health|diagnosis|prescription|patient)\b/i, label: "Health data (HIPAA)" },
  { regex: /\bwithout\s+(filtering|sanitiz|redact|mask)/i, label: "Unfiltered PII output" },
];

// ─── Path Traversal (CWE-22) ───────────────────────────────────────────────
// Source: CVE-2025-53109 (Anthropic filesystem MCP), CVE-2025-53110

const PATH_TRAVERSAL_PATTERNS = [
  { regex: /\.\.[\/\\]/i, label: "Directory traversal sequence" },
  { regex: /%2e%2e[%2f%5c]/i, label: "URL-encoded directory traversal" },
  { regex: /symlink|symbolic\s+link/i, label: "Symlink reference (CVE-2025-53109 pattern)" },
  { regex: /path\.startsWith\s*\(/i, label: "Prefix-only path validation (CVE-2025-53110 pattern)" },
];

// ─── Helpers ────────────────────────────────────────────────────────────────

interface PatternMatch {
  pattern: string;
  label: string;
  location: string;
}

function scanText(
  text: string,
  patterns: Array<{ regex: RegExp; label: string }>,
  location: string
): PatternMatch[] {
  const matches: PatternMatch[] = [];
  for (const p of patterns) {
    if (p.regex.test(text)) {
      matches.push({ pattern: p.regex.source, label: p.label, location });
    }
  }
  return matches;
}

/**
 * Recursively scan all string values in a JSON schema for injection patterns.
 * Tool poisoning extends beyond descriptions to parameter descriptions,
 * enum values, titles, and default values.
 * Source: CyberArk - "Poison Everywhere: No Output from Your MCP Server Is Safe"
 */
function scanSchemaDeep(
  schema: unknown,
  patterns: Array<{ regex: RegExp; label: string }>,
  basePath: string
): PatternMatch[] {
  const matches: PatternMatch[] = [];
  if (typeof schema === "string") {
    matches.push(...scanText(schema, patterns, basePath));
  } else if (Array.isArray(schema)) {
    for (let i = 0; i < schema.length; i++) {
      matches.push(...scanSchemaDeep(schema[i], patterns, `${basePath}[${i}]`));
    }
  } else if (typeof schema === "object" && schema !== null) {
    for (const [key, value] of Object.entries(schema)) {
      matches.push(...scanSchemaDeep(value, patterns, `${basePath}.${key}`));
    }
  }
  return matches;
}

// ─── Input Validation Check ─────────────────────────────────────────────────

function checkInputValidation(tool: McpTool): Vulnerability[] {
  const vulns: Vulnerability[] = [];
  const schema = tool.inputSchema;

  if (
    !schema ||
    !schema.properties ||
    Object.keys(schema.properties as object).length === 0
  ) {
    vulns.push({
      severity: "medium",
      category: "Missing Input Validation",
      tool: tool.name,
      description: `Tool "${tool.name}" accepts no typed parameters — any input passes through unchecked`,
      recommendation:
        "Define a JSON Schema with typed properties, required fields, and constraints",
    });
    return vulns;
  }

  const props = schema.properties as Record<string, any>;

  for (const [propName, propDef] of Object.entries(props)) {
    if (
      propDef.type === "string" &&
      !propDef.maxLength &&
      !propDef.pattern &&
      !propDef.enum
    ) {
      vulns.push({
        severity: "low",
        category: "Missing Input Validation",
        tool: tool.name,
        description: `Parameter "${propName}" is an unconstrained string (no maxLength, pattern, or enum)`,
        recommendation: `Add maxLength, pattern regex, or enum constraints to "${propName}"`,
      });
    }
  }

  return vulns;
}

// ─── Tool Shadowing / Poisoning ─────────────────────────────────────────────
// Source: Invariant Labs - "MCP Security Notification: Tool Poisoning Attacks"
// Source: OWASP AGENTIC04:2026 - "Agentic Supply Chain Vulnerabilities"

function checkToolShadowing(
  tool: McpTool,
  allTools: McpTool[]
): Vulnerability[] {
  const vulns: Vulnerability[] = [];

  // Generic names that commonly shadow legitimate tools
  const SHADOW_TARGETS = new Set([
    "read_file", "write_file", "execute", "run", "search",
    "list", "delete", "create", "update", "get", "fetch",
    "send", "query", "read", "write",
  ]);

  if (SHADOW_TARGETS.has(tool.name)) {
    vulns.push({
      severity: "medium",
      category: "Tool Shadowing",
      tool: tool.name,
      description: `Generic name "${tool.name}" can shadow/impersonate legitimate tools from other servers`,
      recommendation: `Use a namespaced name like "${tool.serverName ?? "server"}_${tool.name}"`,
    });
  }

  // Cross-server name collision
  const dupes = allTools.filter(
    (t) => t.name === tool.name && t.serverId !== tool.serverId
  );
  if (dupes.length > 0) {
    vulns.push({
      severity: "high",
      category: "Tool Shadowing",
      tool: tool.name,
      description: `Tool "${tool.name}" exists on ${dupes.length + 1} servers — enables tool shadowing attacks`,
      recommendation:
        "Remove duplicate or rename. Shadowed tools let a malicious server intercept calls meant for a legitimate one.",
    });
  }

  return vulns;
}

// ─── Lethal Trifecta Detection ──────────────────────────────────────────────
// Source: Simon Willison (June 2025), Invariant Labs GitHub MCP exploit
//
// The combination of these three capabilities on a single server (or across
// servers accessible to the same agent) creates a data exfiltration path:
//   1. Access to private/sensitive data
//   2. Exposure to untrusted external content
//   3. Ability to communicate externally

const PRIVATE_DATA_INDICATORS = /\b(read|get|list|fetch|access|load|retrieve).*(file|email|message|document|repo|database|db|secret|key|config|credential|user|patient|record)/i;
const UNTRUSTED_CONTENT_INDICATORS = /\b(fetch|read|get|load|parse|process|browse|scrape|crawl|search).*(web|url|http|page|html|site|link|content|feed|rss|api|external)/i;
const EXTERNAL_COMMS_INDICATORS = /\b(send|post|publish|push|comment|create|write|upload|transmit|forward|relay).*(email|message|webhook|http|api|issue|comment|slack|discord|request)/i;

export function detectLethalTrifecta(tools: McpTool[]): Vulnerability[] {
  const vulns: Vulnerability[] = [];

  const privateDataTools = tools.filter(
    (t) =>
      PRIVATE_DATA_INDICATORS.test(t.name) ||
      PRIVATE_DATA_INDICATORS.test(t.description || "")
  );
  const untrustedTools = tools.filter(
    (t) =>
      UNTRUSTED_CONTENT_INDICATORS.test(t.name) ||
      UNTRUSTED_CONTENT_INDICATORS.test(t.description || "")
  );
  const externalTools = tools.filter(
    (t) =>
      EXTERNAL_COMMS_INDICATORS.test(t.name) ||
      EXTERNAL_COMMS_INDICATORS.test(t.description || "")
  );

  if (
    privateDataTools.length > 0 &&
    untrustedTools.length > 0 &&
    externalTools.length > 0
  ) {
    vulns.push({
      severity: "critical",
      category: "Lethal Trifecta",
      tool: `${privateDataTools[0].name} + ${untrustedTools[0].name} + ${externalTools[0].name}`,
      description: `Server exposes the Lethal Trifecta: private data access [${privateDataTools.map((t) => t.name).join(", ")}] + untrusted content [${untrustedTools.map((t) => t.name).join(", ")}] + external comms [${externalTools.map((t) => t.name).join(", ")}]. This combination enables full data exfiltration via prompt injection.`,
      recommendation:
        "Apply tool invocation policy 'block_when_context_is_untrusted' on external comms tools, and trusted data policy 'sanitize_with_dual_llm' on untrusted content tools. This breaks the exfiltration chain.",
    });
  }

  return vulns;
}

// ─── Main Analyzer ──────────────────────────────────────────────────────────

export function analyzeToolVulnerabilities(
  tool: McpTool,
  allTools: McpTool[]
): Vulnerability[] {
  const vulns: Vulnerability[] = [];
  const desc = tool.description || "";

  // 1. Prompt injection — scan description AND full schema recursively
  const descInjections = scanText(desc, PROMPT_INJECTION_PATTERNS, "description");
  const schemaInjections = scanSchemaDeep(
    tool.inputSchema,
    PROMPT_INJECTION_PATTERNS,
    "schema"
  );
  for (const m of [...descInjections, ...schemaInjections]) {
    vulns.push({
      severity: "critical",
      category: "Prompt Injection",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Remove hidden instructions. Apply 'block_always' tool invocation policy.",
    });
  }

  // 2. ANSI / steganography attacks
  const stegMatches = [
    ...scanText(desc, STEGANOGRAPHY_PATTERNS, "description"),
    ...scanSchemaDeep(tool.inputSchema, STEGANOGRAPHY_PATTERNS, "schema"),
  ];
  for (const m of stegMatches) {
    vulns.push({
      severity: "critical",
      category: "ANSI/Steganography Attack",
      tool: tool.name,
      description: `${m.label} in ${m.location} — invisible content may contain hidden instructions`,
      recommendation:
        "Strip all ANSI escape sequences and zero-width characters from tool definitions. Apply 'block_always' policy.",
    });
  }

  // 3. Excessive permissions
  const permIssues = [
    ...scanText(desc, EXCESSIVE_PERMISSION_PATTERNS, "description"),
    ...scanSchemaDeep(tool.inputSchema, EXCESSIVE_PERMISSION_PATTERNS, "schema"),
  ];
  for (const m of permIssues) {
    vulns.push({
      severity: "high",
      category: "Excessive Permissions",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Apply least-privilege. Use 'block_when_context_is_untrusted' invocation policy.",
    });
  }

  // 4. Data exfiltration patterns
  const exfilIssues = [
    ...scanText(desc, DATA_EXFILTRATION_PATTERNS, "description"),
    ...scanSchemaDeep(tool.inputSchema, DATA_EXFILTRATION_PATTERNS, "schema"),
  ];
  for (const m of exfilIssues) {
    vulns.push({
      severity: "high",
      category: "Data Exfiltration Risk",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Apply trusted data policy 'sanitize_with_dual_llm' on this tool's output.",
    });
  }

  // 5. Command injection
  const cmdIssues = [
    ...scanText(desc, COMMAND_INJECTION_PATTERNS, "description"),
    ...scanSchemaDeep(tool.inputSchema, COMMAND_INJECTION_PATTERNS, "schema"),
  ];
  for (const m of cmdIssues) {
    vulns.push({
      severity: "high",
      category: "Command Injection",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Never pass user input to shell. Use parameterized calls. Apply 'block_always' policy.",
    });
  }

  // 6. Path traversal
  const pathIssues = scanSchemaDeep(
    tool.inputSchema,
    PATH_TRAVERSAL_PATTERNS,
    "schema"
  );
  for (const m of pathIssues) {
    vulns.push({
      severity: "high",
      category: "Path Traversal",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Validate paths against an allowlist. Resolve symlinks before checking containment.",
    });
  }

  // 7. PII exposure
  const piiIssues = [
    ...scanText(desc, PII_PATTERNS, "description"),
    ...scanSchemaDeep(tool.inputSchema, PII_PATTERNS, "schema"),
  ];
  for (const m of piiIssues) {
    vulns.push({
      severity: "medium",
      category: "PII Exposure",
      tool: tool.name,
      description: `${m.label} in ${m.location}`,
      recommendation:
        "Apply trusted data policy 'sanitize_with_dual_llm' or 'mark_as_untrusted'.",
    });
  }

  // 8. Input validation
  vulns.push(...checkInputValidation(tool));

  // 9. Tool shadowing
  vulns.push(...checkToolShadowing(tool, allTools));

  return vulns;
}

// ─── Basic Trust Score (used by scan_server) ────────────────────────────────

export function calculateBasicTrustScore(vulns: Vulnerability[]): number {
  let score = 100;

  for (const v of vulns) {
    switch (v.severity) {
      case "critical":
        score -= 25;
        break;
      case "high":
        score -= 15;
        break;
      case "medium":
        score -= 8;
        break;
      case "low":
        score -= 3;
        break;
      case "info":
        score -= 1;
        break;
    }
  }

  // Critical vulns cap the score — you can't be "mostly safe"
  const hasCritical = vulns.some((v) => v.severity === "critical");
  if (hasCritical) {
    score = Math.min(score, 35);
  }

  return Math.max(0, Math.min(100, score));
}
